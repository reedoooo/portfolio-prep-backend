(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fetch-auth')) :
  typeof define === 'function' && define.amd ? define(['exports', 'fetch-auth'], factory) :
  (factory((global.jwtAuth = global.jwtAuth || {}),global.fetchAuth));
}(this, function (exports,fetchAuth) { 'use strict';

  fetchAuth = 'default' in fetchAuth ? fetchAuth['default'] : fetchAuth;

  var fetchToken = (function fetchToken(endpoint, auth) {
    var token;
    return Promise.resolve().then(function () {
      return fetchAuth(endpoint, auth, { method: 'POST' });
    }).then(function (_resp) {
      // try to authenticate and get a token
      token = _resp;

      // store the token in local storage under the endpoint for later use

      localStorage.setItem(endpoint, token);

      return token;
    });
  })

  function getExpires(token) {
    return JSON.parse(atob(token.split('.')[1])).exp * 1000 || false;
  }

  function expiresIn(token) {
    var expires = getExpires(token);
    return expires && expires - Date.now();
  }

  function logout(endpoint) {
    localStorage.removeItem(endpoint);
  }

  function tokenFor(endpoint) {
    var token = localStorage.getItem(endpoint) || false;

    if (token && expiresIn(token) <= 0) {
      logout(endpoint);
      token = false;
    }

    return token;
  }

  function createRenew(endpoint, callback) {
    return function () {
      var token, error, newToken;
      return Promise.resolve().then(function () {
        token = tokenFor(endpoint);
        error = undefined;
        newToken = undefined;


        if (token) {
          return Promise.resolve().then(function () {
            return fetchToken(endpoint, 'Bearer ' + token);
          }).then(function (_resp) {
            newToken = _resp;
          }).catch(function (err) {
            error = new Error('Failed to renew token for ' + endpoint);
            error.original = err;
          });
        } else {
          error = new Error('Can\'t find token for ' + endpoint);
        }
      }).then(function () {
        // if we were given a callback to notify someone of new tokens, do it
        if (typeof callback === 'function') {
          callback(newToken, error);
        } else {
          if (error) {
            console.error(error);
          }
        }
      });
    };
  }

  function keepAlive(endpoint, onNewToken) {
    var keepAliveAt = arguments.length <= 2 || arguments[2] === undefined ? 5000 : arguments[2];

    // we'll try to renew the token keepAliveAt seconds before it expires
    var fetchEvery = expiresIn(tokenFor(endpoint)) - keepAliveAt;

    // if there's not enough time to do that we'll throw an error
    if (fetchEvery <= 0) {
      throw Error('Can\'t renew token for ' + endpoint + ' because its expiration time is too short to be able to renew it');
    }

    // essentially run this forever until the user stops it
    var interval = setInterval(createRenew(endpoint, onNewToken), fetchEvery);

    // return a cleanup function so that you can cancel the keepAlive interval when you want to
    return function () {
      return clearInterval(interval);
    };
  }

  var _login = (function login(endpoint, user, password) {
    var basic;
    return Promise.resolve().then(function () {
      // encode user and password in a base64 string
      basic = btoa(user + ':' + password);

      // try to get the token

      return fetchToken(endpoint, 'Basic ' + basic);
    });
  })

  exports.fetchToken = fetchToken;
  exports.expiresIn = expiresIn;
  exports.keepAlive = keepAlive;
  exports.login = _login;
  exports.logout = logout;
  exports.tokenFor = tokenFor;

}));